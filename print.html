<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hacspec</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="language/index.html"><strong aria-hidden="true">2.</strong> The hacspec language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/core.html"><strong aria-hidden="true">2.1.</strong> Core</a></li><li class="chapter-item expanded "><a href="language/seq.html"><strong aria-hidden="true">2.2.</strong> Sequences and arrays</a></li><li class="chapter-item expanded "><a href="language/enums.html"><strong aria-hidden="true">2.3.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="language/errors.html"><strong aria-hidden="true">2.4.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="std/index.html"><strong aria-hidden="true">3.</strong> The hacspec std library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="std/arithmetic.html"><strong aria-hidden="true">3.1.</strong> Arithmetic</a></li><li class="chapter-item expanded "><a href="std/seq.html"><strong aria-hidden="true">3.2.</strong> Sequence and array operations</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">4.</strong> Examples</a></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">5.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/specifications.html"><strong aria-hidden="true">5.1.</strong> Specifications</a></li><li class="chapter-item expanded "><a href="usage/verification.html"><strong aria-hidden="true">5.2.</strong> Verification</a></li><li class="chapter-item expanded "><a href="usage/test_vectors.html"><strong aria-hidden="true">5.3.</strong> Test Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="developers/index.html"><strong aria-hidden="true">6.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="developers/compiler.html"><strong aria-hidden="true">6.1.</strong> Working on the compiler</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hacspec</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>hacspec is a specification language for crypto primitives, protocols, and more.
It is a subset of the <a href="https://www.rust-lang.org/">Rust</a> programming language, focused on functional
programming and it avoids the use of mutable state as much as possible.</p>
<p>This book gives an overview of:</p>
<ul>
<li><a href="./language">The hacspec language</a>;</li>
<li>The different parts of the project:
<ul>
<li><a href="./std">the standard library</a>,</li>
<li><a href="./examples">examples of hacspec programs</a>;</li>
</ul>
</li>
<li>How to use hacspec to write <a href="./usage/specifications.html">specifications</a> for standards and <a href="./usage/verification.html">verification</a>;</li>
<li>How to use hacspec to generate <a href="./usage/test_vectors.html">test vectors</a>;</li>
<li><a href="./developers">Work on the hacspec compiler and tooling itself</a>.</li>
</ul>
<p>For a quick introduction you can also check out these <a href="https://raw.githubusercontent.com/hacspec/hacspec/master/presentation_slides.pdf">slides</a> from April 2021.
An in-depth <a href="https://hal.inria.fr/hal-03176482">technical report</a> is also available, and serves as a reference
for the language formalization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hacspec-language"><a class="header" href="#the-hacspec-language">The hacspec language</a></h1>
<p>This section gives an informal description of the hacspec language, whose
goal is to provide hands-on documentation for users of the language. For
a formal specification of the semantics of the language, please refer
to the <a href="https://hal.inria.fr/hal-03176482">technical report</a>.</p>
<p>hacspec is a domain-specific language embedded inside Rust. This means that
all correct hacspec programs are correct Rust programs: you can use
the usual Rust tooling for working on your hacspec developments. However,
hacspec is a strict subset of Rust: this means that some features of Rust
are forbidden inside hacspec. The goal of restricting the expressiveness of
the language is twofold: first, help domain experts such as cryptographers
convey their specifications in a fashion that should help them avoid
mistakes; second, provide a way for Rust programmers to interact with theorem
provers such as F* or Coq.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-core-of-hacspec"><a class="header" href="#the-core-of-hacspec">The core of hacspec</a></h1>
<h2 id="crates-and-modules"><a class="header" href="#crates-and-modules">Crates and modules</a></h2>
<p>hacspec only supports single-module crates, due to a technical limitation
of the Rust compiler. Inside this single file, a hacspec program shall always
start with:</p>
<pre><code class="language-rust  noplaypen">use hacspec_lib::*;

// Optional: dependencies on other crates containing hacspec programs
use other_hacpsec_crate::*;
</code></pre>
<p>No other form of <code>use</code> is allowed in hacspec, because allowing Rust's
complex import patterns would increase the complexity of the hacspec compiler
and conflict with the module systems of most proof assistants.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>hacspec is a functional language, and only supports the declaration of
top-level functions:</p>
<pre><code class="language-rust  noplaypen">fn hacspec_function(x: bool) -&gt; () {
    ...
}
</code></pre>
<p>The functions can take any number of arguments, and may return a value (or not).
Note that recursive functions are forbidden in hacspec.</p>
<p>The control flow inside hacspec functions is limited, as <code>return</code> statements
are forbidden.</p>
<h2 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h2>
<p>hacspec supports all the Rust primitive types: integers (signed and unsigned),
booleans, unit, tuples. hacspec possesses some support for generic
types, but only for primitive types defined by the language creators, and
not for user-defined types.</p>
<p>Type aliases are allowed in hacspec:</p>
<pre><code class="language-rust  noplaypen">type OneTypeAlias = u32;
</code></pre>
<h2 id="borrows"><a class="header" href="#borrows">Borrows</a></h2>
<p>hacspec forbids mutable borrows in all places. Immutable borrows are allowed
in hacspec, but only for function arguments. Indeed, you can declare a function
argument as immutably borrowed:</p>
<pre><code class="language-rust  noplaypen">fn hacspec_function(arg: &amp;Seq&lt;u8&gt;) {
    ...
}
</code></pre>
<p>You can also immutably borrow a value at the call site of a function:</p>
<pre><code class="language-rust  noplaypen">hacspec_function(&amp;Seq::&lt;u8&gt;::new(64))
</code></pre>
<p>In particular, return types cannot contain references, and the same is true
for types inside tuples or any data structure.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>hacspec allows the declaration of constants:</p>
<pre><code class="language-rust  noplaypen">const ONE_CONST : bool = false;
</code></pre>
<h2 id="assignments"><a class="header" href="#assignments">Assignments</a></h2>
<p>Inside a function body, hacspec allows regular Rust let-bindings:</p>
<pre><code class="language-rust  noplaypen">let x = ...;
</code></pre>
<p>hacspec also allows mutable let bindings, and subsequent reassignments:</p>
<pre><code class="language-rust  noplaypen">let mut x = ...;
...
x = ...;
</code></pre>
<p>This allowing of mutable variable might come as a contradiction to hacspec's
philosophy of forbidding mutable state. But in fact, mutable local variables in
hacspec can be translated to a completely side-effect free form with a state-passing
like monadic structure.</p>
<p>Left-hand sides of assignments support destructuring, which is currently the
only way to access the members of a tuple:</p>
<pre><code class="language-rust  noplaypen">let (x, y) = z;
</code></pre>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Looping is severely restricted in hacspec compared to Rust, as the only accepted form is
<code>for</code> looping with a counter over an integer range:</p>
<pre><code class="language-rust  noplaypen">for i in low..hi {
    ... // The block can use i and reassign mutable variables
}
</code></pre>
<p>The motivation for this restriction is to ease the proof of termination of
loops. <code>break</code> or <code>continue</code> statements are forbidden.</p>
<h2 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h2>
<p>hacspec allows statement-like conditionals as well as expression-like
conditionals:</p>
<pre><code class="language-rust  noplaypen">if cond1 {
    ... // the block can modify mutable variables
} else { // else block is optional here
    ...
}
let x = if cond2 { ... } else { ... };
</code></pre>
<h2 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and expressions</a></h2>
<p>In regular Rust, statements and expressions can be mixed together freely.
This not the case in hacspec that imposes a strict precedence of statements
over expressions. For instance, the following code is not allowed in
hacspec:</p>
<pre><code class="language-rust  noplaypen">let x = if cond {
    y = true; // ERROR: the reassignment is a statement, which cannot
              // be contained in the expression to which x is assigned.
    3
} else {
    4
};
</code></pre>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p>hacspec allows for both <code>pub</code> and non-<code>pub</code> versions of item declarations
(pub, non-pub, etc). You simply have to respect the Rust visibility rules. Note
that these visibility distinctions might not be translated in the proof
backends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequences-and-arrays"><a class="header" href="#sequences-and-arrays">Sequences and arrays</a></h1>
<h2 id="sequences"><a class="header" href="#sequences">Sequences</a></h2>
<p>The staple <code>Vec</code> type is forbidden in hacspec. Instead, you have to use the
type <code>Seq</code>, which is implemented as a wrapper around <code>Vec</code>.</p>
<p>The most notable differences between <code>Seq</code> and <code>Vec</code> is that <code>Seq</code> is not
resizable, and does not support <code>push</code> and <code>pop</code> operations. Instead, the
final length of the seq has to be provided at creation time. See the
hacspec standard library documentation for more details.</p>
<p><code>Seq</code> is a built-in generic type that always has to be indexed by the content of the
cells: <code>Seq&lt;u8&gt;</code>, etc.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>The native Rust array types <code>[&lt;type of contents&gt;, &lt;size&gt;]</code> is forbidden in
hacspec. Instead, you have to declare nominally at the top-level new array types
for a specific cell content and size with:</p>
<pre><code class="language-rust  noplaypen">array!(FooArray, u8, 64);
// This declares type FooArray as an array of u8 of size 64
bytes!(BarArray, 64);
// bytes! is a specialized version of array! with secret bytes
array!(BazArray, u8, 64, type_for_indexes:BazIndex);
// The additional argument type_for_indexes defines an alias of usize
// intended to spot which usizes are used to index BazArray (useful for
// verification)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and enums</a></h1>
<p>hacspec also supports user-defined structs and enums with some restrictions.</p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>The only form of struct declaration currently allowed in hacspec is:</p>
<pre><code class="language-rust  noplaypen">struct Foo(u32, Seq&lt;u32&gt;);
</code></pre>
<p>The struct thus declared can have one or more components. This form of struct
declaration effectively corresponds to a single-case enum, and is implemented
as such. Struct components can be accessed through let-binding destructuring:</p>
<pre><code class="language-rust  noplaypen">let Foo(x, y) = z;
</code></pre>
<p>Note that you can't store borrowed types inside hacspec structs, hence there is no
need for lifetime variables.</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>hacspec supports very restricted <code>enum</code> declarations:</p>
<pre><code class="language-rust  noplaypen">enum Foo {
    CaseA,
    CaseB(u16),
    CaseC(Seq&lt;bool&gt;, u64)
}
</code></pre>
<p>These declaration don't support the basic Rust features such as C-style
union declarations with assignments for each case.</p>
<p>Enumeration values can be pattern-matched in an expression:</p>
<pre><code class="language-rust  noplaypen">match x {
    Foo::CaseA =&gt; ...,
    Foo::CaseB(y) =&gt; ...,
    Foo::CaseC(y,z) =&gt; ...
}
</code></pre>
<p>Note that you can't store borrowed types inside hacspec enums, hence there is no
need for lifetime variables.</p>
<h2 id="option-and-result"><a class="header" href="#option-and-result">Option and Result</a></h2>
<p>User-defined structs and enums presented above don't support generic type
parameters yet. However, the built-in enums <code>Option&lt;T&gt;</code> and <code>Result&lt;T,U&gt;</code>
support type parameters. Those type parameters have to be explicitly declared
each time, as hacspec does not currently support type inference:</p>
<pre><code class="language-rust  noplaypen">match x {
    Result::&lt;Seq&lt;u8&gt;, bool&gt;::Ok(y) =&gt; ...,
    Result::&lt;Seq&lt;u8&gt;, bool&gt;::Err(err) =&gt; ...
}
</code></pre>
<p>Such type parameter declaration is cumbersome; as a workaround we advise
to declare a type alias as such:</p>
<pre><code class="language-rust  noplaypen">type MyResult = Result::&lt;Seq&lt;u8&gt;, bool&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Error handling in Rust is done via the <code>Result</code> type (see the structs and
enums section). But on top of explicit pattern-matching, hacspec also
supports the popular <code>?</code> operator to quickly perform an early return and
propagate the error case upwards.</p>
<p><code>?</code> is only allowed at the very end of an expression in a let-binding or
reassignment statement:</p>
<pre><code class="language-rust  noplaypen">let x = foo(true)?; // GOOD
let y = foo(bar(0)?); // ERROR: the ? is not at the end of the statement
</code></pre>
<p>Currently, <code>?</code> is the only way to return early in a hacspec function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hacspec-std-library"><a class="header" href="#the-hacspec-std-library">The hacspec std library</a></h1>
<p>The hacspec standard library contains a host of functions, type generators
and methods that define the base objects manipulated in classic cryptographic
primitives.</p>
<p>Methods in the standard library can be divided into three categories:</p>
<ol>
<li>The <code>not_hacspec</code> methods whose signature and body does not belong to the
hacspec fragment of Rust. They should not be used in hacspec code, but can
be used as helpers for e.g. testing.</li>
<li>The <code>unsafe_hacspec</code> methods whose signature belongs to hacspec but not
the body. These methods can be used in hacspec programs but their body
is part of the trusted codebase.</li>
<li>The <code>in_hacspec</code> methods whose signatures and bodies belong to the
hacspec fragment of Rust. These can be used safely in hacspec programs.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h1>
<p>hacspec overloads the arithmetic operators for a wide variety of types
corresponding to mathematical values mentioned in cryptographic specifications.</p>
<h2 id="the-numeric-trait"><a class="header" href="#the-numeric-trait">The <code>Numeric</code> trait</a></h2>
<p>All of these types implement the <code>Numeric</code> trait defined by the hacspec standard
library. The arithmetic operators work for all kinds of integers, but also
arrays and sequences (point-wise operations).</p>
<p>Note that the list of types implementing <code>Numeric</code> is hardcoded in the
hacspec compiler, and as of this day cannot be extended by the user.</p>
<p>While the Rust compiler can infer the type of integer literals automatically,
this feature is not implemented by the hacspec compiler:</p>
<pre><code>let w: u32 = 0; // ERROR: an integer without a suffix will have type usize
let x: u64 = 0x64265u64; // GOOD
let y: u64 = 4u64; // GOOD
</code></pre>
<h2 id="public-and-secret-integers"><a class="header" href="#public-and-secret-integers">Public and secret integers</a></h2>
<p>One of hacspec's goal is to enable users quickly check whether their
application does not obviously break the constant-time guarantee.
Certain processor instructions take more or less time to complete depending
on their inputs, which can cause secret leakage and break the security of
an application. Hence, hacspec offers for each type of integer (<code>u8</code>, <code>u32</code>, etc.)
a mirror secret integer type (<code>U8</code>, <code>U32</code>, etc.) for which operations
that break constant-timedness are forbidden.</p>
<p>This public/private distinction can be found at a lot of places in the standard
library, and is made to forbid functions and data structures from leaking secrets.</p>
<p>Conversions between public and secret integers are restricted to two functions:
<code>classify</code> and <code>declassify</code>.</p>
<h2 id="abstract-integers"><a class="header" href="#abstract-integers">Abstract integers</a></h2>
<p>Some cryptographic specifications talk about modular arithmetic in large
fields, whose size overflows even <code>u128</code>. To ease the expression of such
specifications, hacspec offers wrapper types around <code>BigInt</code> that can be
declared using the following API:</p>
<pre><code class="language-rust  noplaypen">abstract_nat_mod!(
    NameOfModularInts,
    NameOfUnderlyingByteRepresentation,
    256, // Number of bits for the representation of the big integer,
    &quot;ffffffffffffffff00000000000065442&quot;, // Hex representation of the modulo value as hex
)

abstract_public_nat_mod!(
    ... // Public version of above
)
</code></pre>
<h2 id="integers-as-bytes"><a class="header" href="#integers-as-bytes">Integers as bytes</a></h2>
<p>It is often useful to view an integer as a sequence of bytes that can be
manipulated individually. The hacspec standard library provides a number
of function to translate back and forth from integer to sequence of bytes:</p>
<pre><code class="language-rust  noplaypen">pub fn u16_to_le_bytes(x: u16) -&gt; u16Word;

pub fn u16_from_le_bytes(s: u16Word) -&gt; u16;

pub fn U64_to_be_bytes(x: U64) -&gt; U64Word;

pub fn U64_from_be_bytes(s: U64Word) -&gt; U64;

...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-and-array-operations"><a class="header" href="#sequence-and-array-operations">Sequence and array operations</a></h1>
<p>While the types for <a href="std//language/seq.html">sequence and arrays</a> has been introduced
earlier,</p>
<h2 id="operations-common-to-sequences-and-arrays"><a class="header" href="#operations-common-to-sequences-and-arrays">Operations common to sequences and arrays</a></h2>
<h3 id="base-traits"><a class="header" href="#base-traits">Base traits</a></h3>
<p>Some operations are common to both <a href="std//language/seq.html">sequences and arrays</a>
by design, and can be used as the interoperability base between the two types
of collections. These operations are the following:</p>
<ul>
<li><code>len</code>: gives the length of an array or sequence;</li>
<li><code>iter</code>: iterates over the content of the array or sequence
(unsafe in hacspec but can be used for implementing primitives)</li>
<li><code>create</code>: creates a sequence or array and initializes the elements to the
default value (0 for arithmetic types);</li>
<li><code>update_slice</code>, <code>update</code> and <code>update_start</code>: produce a new sequence or array
with modified contents.</li>
</ul>
<p>Both sequences and arrays implement indexing with any type of unsigned public
integer.</p>
<h3 id="chunking"><a class="header" href="#chunking">Chunking</a></h3>
<p>Both arrays and sequences support chunking with methods like:</p>
<ul>
<li><code>num_chunks</code> and <code>num_exact_chunks</code> (whole or partial blocks);</li>
<li><code>get_chunk</code>, <code>get_exact_chunk</code> and <code>get_remainder_chunk</code>;</li>
<li><code>set_chunk</code> and <code>set_exact_chunk</code>.</li>
</ul>
<p>The read operations borrow the sequence or array, but the write operations
create a new sequence or array.</p>
<h3 id="conversions"><a class="header" href="#conversions">Conversions</a></h3>
<p>Sequences and arrays can be created from other types via methods like:</p>
<ul>
<li><code>from_public_slice</code> and <code>from_slice</code>;</li>
<li><code>from_vec</code> and <code>from_native_slice</code>;</li>
<li><code>from_public_seq</code> and <code>from_seq</code> (to convert a seq into an array of the correct size);</li>
<li><code>from_string</code> and <code>from_hex</code> for byte or hex strings (hex only for <code>u8</code> sequences and arrays).</li>
</ul>
<h3 id="secrecy"><a class="header" href="#secrecy">Secrecy</a></h3>
<p>The methods prefixed by <code>public</code> performs an element-wise classification of the
data under the hood.</p>
<h3 id="ownage"><a class="header" href="#ownage">Ownage</a></h3>
<p>Some mehtods have two versions: an <code>owned</code> and a non-<code>owned</code> version, depending
on whether the <code>self</code> argument is consumed or not by the method. This distinction
is useful to avoid unnecessary copies and thus be more performant.</p>
<h2 id="array-specific-operations"><a class="header" href="#array-specific-operations">Array-specific operations</a></h2>
<p>Since array length is known statically, <code>new</code> does not take any argument,
same as <code>length</code>. <code>slice</code>s of arrays become <code>Seq</code>.</p>
<h2 id="sequence-specific-operations"><a class="header" href="#sequence-specific-operations">Sequence-specific operations</a></h2>
<p>Sequences can be extended (by creating a new sequence under the hood) with
<code>push</code> or <code>concat</code>. Sequences can also be sliced with <code>slice</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>The main <a href="https://github.com/hacspec/hacspec/">hacspec repository</a> contains a set of <a href="https://github.com/hacspec/hacspec/tree/master/examples">example specifications</a>.
In this section we pull out some interesting bits to demonstrate the hacspec
language.</p>
<p>There's also a provider that bundles the different cryptographic primitives
into a single library.
The provider implements the <a href="https://github.com/RustCrypto/traits">RustCrypto traits</a> in order to facilitate interoperability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifications"><a class="header" href="#specifications">Specifications</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification"><a class="header" href="#verification">Verification</a></h1>
<h2 id="coq"><a class="header" href="#coq">Coq</a></h2>
<h3 id="quickcheck--quickchick"><a class="header" href="#quickcheck--quickchick">QuickCheck / QuickChick</a></h3>
<p>You can test your hacspec code using quickcheck, simply implmenet Arbitrary for the type you want to generate tests for, e.g.</p>
<pre><code class="language-rust ignore">impl Arbitrary for Fp {
    fn arbitrary(g: &amp;mut Gen) -&gt; Fp {
        let mut a: [u64; 6] = [0; 6];
        for i in 0..6 {
            a[i] = u64::arbitrary(g);
        }
        let mut b: [u8; 48] = [0; 48];
        for i in 0..6 {
            let val: u64 = a[i];
            b[(i*8)..((i+1)*8)].copy_from_slice(&amp;(val.to_le_bytes()));
        }
        Fp::from_byte_seq_le(Seq::&lt;U8&gt;::from_public_slice(&amp;b))
    }
}
</code></pre>
<p>then you can use the QuickCheck attribute, to make QuickCheck do property based testing for this function,</p>
<pre><code class="language-rust ignore">#[cfg(test)]
#[quickcheck] //Using the fp arbitraty implementation from above to generate fp2 elements.
fn test_fp2_prop_add_neg(a: Fp2) -&gt; bool {
    let b = fp2neg(a);
    fp2fromfp(Fp::ZERO()) == fp2add(a, b)
}
</code></pre>
<p>which will run when you do <code>cargo test</code>. If you then add the tag <code>#[cfg(proof)]</code> and export to Coq,</p>
<pre><code>cargo hacspec -o coq/src/&lt;output_file_name&gt;.v &lt;input_crate_name&gt;
</code></pre>
<p>then you get the QuickChick test,</p>
<pre><code>Definition test_fp2_prop_add_neg (a_320 : fp2) : bool :=
  let b_321 :=
    fp2neg (a_320) in
  (fp2fromfp (nat_mod_zero )) =.? (fp2add (a_320) (b_321)).

QuickChick (forAll g_fp2 (fun a_320 : fp2 =&gt;test_fp2_prop_add_neg a_320)).
</code></pre>
<p>and generators will be constructed for the types automatically as,</p>
<pre><code>Instance show_fp : Show (fp) := Build_Show (fp) (fun x =&gt; show (GZnZ.val _ x)).
Definition g_fp : G (fp) := @bindGen Z (fp) (arbitrary) (fun x =&gt; returnGen (@Z_in_nat_mod _ x)).
Instance gen_fp : Gen (fp) := Build_Gen fp g_fp.
</code></pre>
<p>which you can then run through coq in the folder <code>coq/</code></p>
<pre><code>coqc -R src/ Hacspec src/&lt;output_file_name&gt;.v
</code></pre>
<p>Make sure you run:</p>
<pre><code>coqc -R src/ Hacspec src/MachineIntegers.v
coqc -R src/ Hacspec src/Lib.v
</code></pre>
<p>or <code>make</code> to generate the <code>.vo</code> files used by <code>&lt;output_file_name&gt;.v</code>.</p>
<p>For more information:</p>
<ul>
<li>on QuickCheck (in rust): <a href="https://github.com/BurntSushi/quickcheck">BurntSushi/quickcheck</a></li>
<li>on QuickChick: <a href="https://softwarefoundations.cis.upenn.edu/qc-current/index.html">Software foundations book on QuickChick</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-vectors"><a class="header" href="#test-vectors">Test Vectors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h1>
<p>This section contains a handy guide for hacspec developers working on the
standard library or the compiler.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-on-the-compiler"><a class="header" href="#working-on-the-compiler">Working on the compiler</a></h1>
<h2 id="high-level-architecture"><a class="header" href="#high-level-architecture">High-level architecture</a></h2>
<p><img src="developers/hacspec_architecture.png" alt="Hacspec compiler architecture" /></p>
<p>The Rustspec compiler intervenes after the regular Rust typechecking,
and takes the Rust AST to translate it into a stricter hacspec AST,
yielding error messages if you're not in the subset.</p>
<p>The hacspec AST then undergoes a typechecking phase that replicates the
formal typechecking judgment of hacspec, before being compiled
to the proof backends like F* or Coq.</p>
<h2 id="code-organization"><a class="header" href="#code-organization">Code organization</a></h2>
<p>The source code for the compiler is located in the <code>language/</code> folder.
<code>main.rs</code> is the file containing the driver for the different compiler
passes.</p>
<h3 id="hacspec-ast"><a class="header" href="#hacspec-ast">Hacspec AST</a></h3>
<p>The main file of the compiler is <code>rustspec.rs</code> and it contains the AST
structure.</p>
<p>Types are usually enclosed into <code>Spanned&lt;...&gt;</code> blocks that attach a location
information to an AST node, thereby providing a way to display beautiful error
message.</p>
<p>Several nodes also contain a <code>Fillable&lt;...&gt;</code> node standing for information
that is filled by the typechecking phase but that can be left to <code>None</code> when
building the AST.</p>
<h3 id="translation-from-rust-ast"><a class="header" href="#translation-from-rust-ast">Translation from Rust AST</a></h3>
<p>This phase is contained in <code>ast_to_rustspec.rs</code>. The trickyness of this
translation is that it needs o be aware of certain special names contained
in the structure <code>SpecialNames</code>. Indeed, while the Rust AST treats the application
enum constructors like function applications, the hacspec AST considers them as
proper injection so we need to distinguish them in the Rust AST. For that, we
need to know all declared enums at this point of the program.</p>
<p>Enums and other <code>SpecialNames</code> are also defined in the <code>ExternalData</code> that
contains the signatures and types imported in crates used by the hacspec
program being compiled.</p>
<h3 id="name-resolution"><a class="header" href="#name-resolution">Name resolution</a></h3>
<p>When the translation from Rust AST is finished, the identifiers for all
variables inside function bodies are of the following type:</p>
<pre><code class="language-rust  noplaypen">pub enum Ident {
    Unresolved(String),
    Local(LocalIdent),
    TopLevel(TopLevelIdent),
}
</code></pre>
<p>More precisely, they are still in the <code>Ident::Unresolved</code> case. The compiler
pass in <code>name_resolution.rs</code> resolves the identifiers by linking them to local or global identifiers,
each one having a unique ID. hacspec does not feature De Bruijn variable
handling, instead relying on unique fresh IDs for differentiating local
and global variables from each other.</p>
<h3 id="external-data"><a class="header" href="#external-data">External data</a></h3>
<p>A hacspec file can never almost never be considered alone, as it usually imports
at least several other crates like the hacspec standard library. These external
crates must pre-populate the typechecking context with the types and function
signatures that they define.</p>
<p>It's the job of <code>hir_to_rustspec.rs</code> to retrieve this data. The critical
piece of code in this file is <a href="https://github.com/hacspec/hacspec/blob/cc609254b0aa978646f494291b9c91a92fe107ee/language/src/hir_to_rustspec.rs#L733-L737">the following</a>:</p>
<pre><code class="language-rust  noplaypen">let num_def_ids = crate_store.num_def_ids_untracked(*krate_num);
let def_ids = (0..num_def_ids).into_iter().map(|id| DefId {
    krate: *krate_num,
    index: DefIndex::from_usize(id),
});
</code></pre>
<p>First, we retrieve the number of exported symbols by an external crate using
<code>num_def_ids_untracked</code>, a function that is <a href="https://github.com/rust-lang/rust/pull/85889">specifically labeled</a>
as critical to the hacspec compiler in the Rust compiler codebase. Then,
we manufacture definition IDs for all these exported symbols, relying on the
invariant that they are numbered from 0 to the number of exported symbols
in Rust's compiled crate metadata format.</p>
<p>Then, we use those definition IDs (<code>DefId</code>) to query the Rust compiler
via the central <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyCtxt.html"><code>TyCtxt</code></a>
data structure. If the <code>DefId</code> corresponds to a type definition, we examine the
type definition structurally and check whether it corresponds to a hacspec-compatible
type definition. Notably, the type definitions generated by macros like <code>array!</code>
or <code>nat_mod!</code> are only seen here in their expanded version, so we have to retro-engineer
which expanded version corresponds to which macro expansion. This is a vulnerability
of the compiler since it's possible to break the abstraction of the language
by smuggling in a type not defined via a hacspec macro this way. That's why hacspec
developers should be very careful about which dependencies they import in order
to have a 100% safety guarantee.</p>
<p>For <code>DefId</code>s corresponding to functions, the signature of the function is analysed
and if it fits the subset of types expected by hacspec, the function is imported
along with its type in a pre-populated typechecking context.</p>
<p>Note that it is not possible any more at this point to retrieve the <code>#[in_hacspec]</code>,
<code>#[unsafe_hacspec]</code>, etc. attributes that would tag the external definitions,
since these attributes get erased by the Rust compiler before reaching the
compiled crates metadata.</p>
<h3 id="typechecking"><a class="header" href="#typechecking">Typechecking</a></h3>
<p>The typechecking is done in <code>typechecker.rs</code> and follows a very regular structure,
making heavy use of immutable data structures to not mess up the various
context manipulations.</p>
<p>Note that we need to perform a full typechecking complete with method resolution
because the proof backends need very fine-grained typechecking information
to generate correct code.</p>
<p>Be careful: types often need to be de-aliased with <code>dealias_type</code> before
being matched on structurally. Forgetting to dealias will lead to bugs with
type aliases.</p>
<h3 id="proof-backends"><a class="header" href="#proof-backends">Proof backends</a></h3>
<p>The different proof backends (<code>rustspec_to_fstar.rs</code>, etc) all enjoy a similar
structure that ought to be refactored to showcase their commonality. The backends
don't use an intermediate AST to generate the code in the proof assistant but
rather directly print code as string using the <a href="https://crates.io/crates/pretty"><code>pretty</code></a>
pretty-printing library. If you want to start a new proof backend, the easiest
solution is probably to copy an existing proof backend and tweak it until
you get the right result.</p>
<p>The code generation has to be fine-tuned to interface with a replica of the
hacspec standard library in the host proof assistant, whose correspondence with
the original hacspec library in Rust is part of the trusted code base. More specially,
clever solutions to encode sequences and array, as well as all the different types
of public and secret machine integers, and the interaction between the two
(seeing a double as a string of bytes) have to be implemented through proof
assistant libraries.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>The compiler has various unit tests that are control trough the <code>language/tests</code>
files. Please enrich the unit tests bases in <code>language-tests</code>,
<code>negative-language-tests</code> and <code>test-crate</code> as you implement new features for
the compiler. The compiler can also be tested against all the hacspec cryptographic
specifications by running <code>examples/typecheck_examples.sh</code> from the root of
the repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>A list of contributors to the hacspec project.</p>
<ul>
<li>Franziskus Kiefer (<a href="https://github.com/franziskuskiefer/">franziskuskiefer</a>)</li>
<li>Denis Merigoux (<a href="https://github.com/denismerigoux">denismerigoux</a>)</li>
<li>Karthik Bhargavan</li>
<li>Tomer Yavor (<a href="https://github.com/TomerHawk">TomerHawk</a>)</li>
<li>Tanmay Garg (<a href="https://github.com/tanmay2004">tanmay2004</a>)</li>
<li>Peter Schwabe (<a href="https://github.com/cryptojedi">cryptojedi</a>)</li>
<li>Kaspar Schleiser (<a href="https://github.com/kaspar030">kaspar030</a>)</li>
<li><a href="https://github.com/Kasserne">Kasserne</a></li>
<li>Tony Arcieri (<a href="https://github.com/tarcieri">tarcieri</a>)</li>
</ul>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
